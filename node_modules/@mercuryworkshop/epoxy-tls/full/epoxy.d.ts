/* tslint:disable */
/* eslint-disable */

type EpoxyIoStream = {
	read: ReadableStream<Uint8Array>,
	write: WritableStream<Uint8Array>,
}


export class EpoxyClient {
/**
** Return copy of self without private attributes.
*/
  toJSON(): Object;
/**
* Return stringified version of self.
*/
  toString(): string;
  free(): void;
  /**
   * @param {any} wisp_url
   * @param {EpoxyClientOptions} options
   */
  constructor(wisp_url: any, options: EpoxyClientOptions);
  /**
   * @returns {Promise<void>}
   */
  replace_stream_provider(): Promise<void>;
  /**
   * @param {EpoxyHandlers} handlers
   * @param {string} url
   * @param {(string)[]} protocols
   * @param {any} headers
   * @returns {Promise<EpoxyWebSocket>}
   */
  connect_websocket(handlers: EpoxyHandlers, url: string, protocols: (string)[], headers: any): Promise<EpoxyWebSocket>;
  /**
   * @param {string} url
   * @returns {Promise<EpoxyIoStream>}
   */
  connect_tcp(url: string): Promise<EpoxyIoStream>;
  /**
   * @param {string} url
   * @returns {Promise<EpoxyIoStream>}
   */
  connect_tls(url: string): Promise<EpoxyIoStream>;
  /**
   * @param {string} url
   * @returns {Promise<EpoxyIoStream>}
   */
  connect_udp(url: string): Promise<EpoxyIoStream>;
  /**
   * @param {string} url
   * @param {object} options
   * @returns {Promise<Response>}
   */
  fetch(url: string, options: object): Promise<Response>;
  buffer_size: number;
  redirect_limit: number;
  user_agent: string;
}
export class EpoxyClientOptions {
  free(): void;
  constructor();
  buffer_size: number;
  disable_certificate_validation: boolean;
  pem_files: (string)[];
  redirect_limit: number;
  title_case_headers: boolean;
  udp_extension_required: boolean;
  user_agent: string;
  websocket_protocols: (string)[];
  wisp_v2: boolean;
}
export class EpoxyHandlers {
  free(): void;
  /**
   * @param {Function} onopen
   * @param {Function} onclose
   * @param {Function} onerror
   * @param {Function} onmessage
   */
  constructor(onopen: Function, onclose: Function, onerror: Function, onmessage: Function);
  onclose: Function;
  onerror: Function;
  onmessage: Function;
  onopen: Function;
}
export class EpoxyWebSocket {
  free(): void;
  /**
   * @param {any} payload
   * @returns {Promise<void>}
   */
  send(payload: any): Promise<void>;
  /**
   * @param {number} code
   * @param {string} reason
   * @returns {Promise<void>}
   */
  close(code: number, reason: string): Promise<void>;
}
export class IntoUnderlyingByteSource {
  free(): void;
  /**
   * @param {ReadableByteStreamController} controller
   */
  start(controller: ReadableByteStreamController): void;
  /**
   * @param {ReadableByteStreamController} controller
   * @returns {Promise<any>}
   */
  pull(controller: ReadableByteStreamController): Promise<any>;
  cancel(): void;
  readonly autoAllocateChunkSize: number;
  readonly type: string;
}
export class IntoUnderlyingSink {
  free(): void;
  /**
   * @param {any} chunk
   * @returns {Promise<any>}
   */
  write(chunk: any): Promise<any>;
  /**
   * @returns {Promise<any>}
   */
  close(): Promise<any>;
  /**
   * @param {any} reason
   * @returns {Promise<any>}
   */
  abort(reason: any): Promise<any>;
}
export class IntoUnderlyingSource {
  free(): void;
  /**
   * @param {ReadableStreamDefaultController} controller
   * @returns {Promise<any>}
   */
  pull(controller: ReadableStreamDefaultController): Promise<any>;
  cancel(): void;
}

export type InitInput = RequestInfo | URL | Response | BufferSource | WebAssembly.Module;

/**
* If `module_or_path` is {RequestInfo} or {URL}, makes a request and
* for everything else, calls `WebAssembly.instantiate` directly.
*
* @param {{ module_or_path: InitInput | Promise<InitInput> }} module_or_path - Passing `InitInput` directly is deprecated.
*
* @returns {Promise<void>}
*/
export default function __wbg_init (module_or_path?: { module_or_path: InitInput | Promise<InitInput> } | InitInput | Promise<InitInput>): Promise<void>;
export const info: { version: string, minimal: boolean, release: boolean };
